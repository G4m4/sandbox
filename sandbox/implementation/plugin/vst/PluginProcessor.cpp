/// @filename PluginProcessor.cpp
/// @brief SandBox plugin processor (audio)
/// @author gm
/// @copyright gm 2013
///
/// This file is part of SandBox
///
/// SandBox is free software: you can redistribute it and/or modify
/// it under the terms of the GNU General Public License as published by
/// the Free Software Foundation, either version 3 of the License, or
/// (at your option) any later version.
///
/// SandBox is distributed in the hope that it will be useful,
/// but WITHOUT ANY WARRANTY; without even the implied warranty of
/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
/// GNU General Public License for more details.
///
/// You should have received a copy of the GNU General Public License
/// along with SandBox.  If not, see <http://www.gnu.org/licenses/>.


// This file is NOT generated by Juce (at least not after the first time),
// That's why we apply our coding style here

#include "sandbox/implementation/plugin/vst/PluginProcessor.h"

#include "sandbox/implementation/plugin/vst/PluginEditor.h"

SandBoxAudioProcessor::SandBoxAudioProcessor()
: process_time_(0.0),
  sandbox_() {
}

SandBoxAudioProcessor::~SandBoxAudioProcessor() {
}

const juce::String SandBoxAudioProcessor::getName() const {
  return JucePlugin_Name;
}

int SandBoxAudioProcessor::getNumParameters() {
  return 1;
}

float SandBoxAudioProcessor::getParameter(int index) {
  return 0.0f;
}

void SandBoxAudioProcessor::setParameter(int index, float newValue) {
  // Inform UI of any change
  sendChangeMessage();
}

const juce::String SandBoxAudioProcessor::getParameterName(int index) {
  return juce::String(sandbox_.DoSomething());
}

const juce::String SandBoxAudioProcessor::getParameterText(int index) {
  return juce::String(sandbox_.DoSomething());
}

const juce::String SandBoxAudioProcessor::getInputChannelName(
    int channelIndex) const {
  return juce::String(channelIndex + 1);
}

const juce::String SandBoxAudioProcessor::getOutputChannelName(
    int channelIndex) const {
  return juce::String(channelIndex + 1);
}

bool SandBoxAudioProcessor::isInputChannelStereoPair(int index) const {
  return true;
}

bool SandBoxAudioProcessor::isOutputChannelStereoPair(int index) const {
  return true;
}

bool SandBoxAudioProcessor::acceptsMidi() const {
  #if JucePlugin_WantsMidiInput
  return true;
  #else
  return false;
  #endif
}

bool SandBoxAudioProcessor::producesMidi() const {
  #if JucePlugin_ProducesMidiOutput
  return true;
  #else
  return false;
  #endif
}

bool SandBoxAudioProcessor::silenceInProducesSilenceOut() const {
  return false;
}

double SandBoxAudioProcessor::getTailLengthSeconds() const {
  return 0.0;
}

int SandBoxAudioProcessor::getNumPrograms() {
  return 0;
}

int SandBoxAudioProcessor::getCurrentProgram() {
  return 0;
}

void SandBoxAudioProcessor::setCurrentProgram(int index) {
}

const String SandBoxAudioProcessor::getProgramName(int index) {
  return String::empty;
}

void SandBoxAudioProcessor::changeProgramName(int index,
                                               const juce::String& newName) {
}

void SandBoxAudioProcessor::prepareToPlay(double sampleRate,
                                           int samplesPerBlock) {
  // Notify UI of the last changes
  sendChangeMessage();
}

void SandBoxAudioProcessor::releaseResources() {
  // When playback stops, you can use this as an opportunity to free up any
  // spare memory, etc.
}

void SandBoxAudioProcessor::processBlock(juce::AudioSampleBuffer& buffer,
                                          juce::MidiBuffer& midiMessages) {
  const double counter_start(juce::Time::getMillisecondCounterHiRes());
  process_time_ = juce::Time::getMillisecondCounterHiRes() - counter_start;
}

bool SandBoxAudioProcessor::hasEditor() const {
  return true;
}

AudioProcessorEditor* SandBoxAudioProcessor::createEditor() {
  return new SandBoxAudioProcessorEditor(this);
}

void SandBoxAudioProcessor::getStateInformation(juce::MemoryBlock& destData) {
  // You should use this method to store your parameters in the memory block.
  // You could do that either as raw data, or use the XML or ValueTree classes
  // as intermediaries to make it easy to save and load complex data.
}

void SandBoxAudioProcessor::setStateInformation(const void* data,
                                                 int sizeInBytes) {
}

void SandBoxAudioProcessor::addChangeListener(
    juce::ChangeListener* listener) {
  // Call parent method
  ChangeBroadcaster::addChangeListener(listener);
  // Update newly added listener
  sendChangeMessage();
}

// DEBUG
double SandBoxAudioProcessor::GetLastProcessTime() const {
  return process_time_;
}
//  /DEBUG

AudioProcessor* JUCE_CALLTYPE createPluginFilter() {
  return new SandBoxAudioProcessor();
}
